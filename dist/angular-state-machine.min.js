/**
 * AngularJS service to implement a finite state machine.
 * @version v1.0.1 - 2020-07-28
 * @link https://github.com/brramos/angular-state-machine
 * @author Billy Ramos <billyrramos@gmail.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

"use strict";var FSM=angular.module("FSM",[]);function MachineConfiguration(a){var i={},s=[],o={};this.getStates=function(){return i},this.getMessages=function(){return s},this.getTransitions=function(){return o},this.extend=function(t){a=angular.merge(a,t)},this.configure=function(){if(!a.hasOwnProperty("init"))throw"You have to create 'init' state.";for(var t in a)if(a.hasOwnProperty(t)){var e=a[t];e.name=t;var n={};if(e.hasOwnProperty("transitions")){for(var r in n=e.transitions)n.hasOwnProperty(r)&&s.indexOf(r)<0&&s.push(r);delete e.transitions}o.hasOwnProperty(t)||(o[t]={}),angular.extend(o[t],n),i.hasOwnProperty(t)||(i[t]={}),angular.extend(i[t],e)}}}function StateMachine(n,r){this.initialize=function(){n.initialize(r)},this.getCurrentState=function(){return n.getCurrentState()},this.getStates=function(){return n.getStates(r)},this.getMessages=function(){return n.getMessages(r)},this.hasMessage=function(t){return n.hasMessage(r,t)},this.isAvailable=function(t){return n.isAvailable(r,t)},this.available=function(){return n.available(r)},this.send=function(t,e){return n.send(r,t,e)}}function MachineStrategy(){}function SyncStrategy(t,e){MachineStrategy.call(this),this.currentState=null,this.$q=t,this.$injector=e,this.lastPromise=null}FSM.provider("stateMachine",function(){var n;this.config=function(t){n=t},this.$get=["$q","$injector",function(t,e){return new StateMachine(new SyncStrategy(t,e),new MachineConfiguration(n))}]}),MachineStrategy.prototype.initialize=function(t){},MachineStrategy.prototype.getCurrentState=function(){},MachineStrategy.prototype.getStates=function(t){},MachineStrategy.prototype.getMessages=function(t){},MachineStrategy.prototype.hasMessage=function(t,e){},MachineStrategy.prototype.isAvailable=function(t,e){},MachineStrategy.prototype.available=function(t){},MachineStrategy.prototype.send=function(t,e,n,r){},MachineStrategy.prototype=new MachineStrategy,SyncStrategy.prototype.initialize=function(t){t.configure();var e=t.getStates();this.currentState=e.init,this.currentState.params={}},SyncStrategy.prototype.getCurrentState=function(){var t=this;return this.$q.when(this.lastPromise).then(function(){return t.currentState.name}).catch(function(){return t.$q.when(t.currentState.name)})},SyncStrategy.prototype.getStates=function(t){return Object.keys(t.getStates())},SyncStrategy.prototype.getMessages=function(t){return t.getMessages()},SyncStrategy.prototype.hasMessage=function(t,e){return 0<=t.getMessages().indexOf(e)},SyncStrategy.prototype.isAvailable=function(t,e){var n=this,r=t.getTransitions();return this.$q.when(this.lastPromise).then(function(){return r[n.currentState.name].hasOwnProperty(e)}).catch(function(){var t=r[n.currentState.name];return n.$q.when(t.hasOwnProperty(e))})},SyncStrategy.prototype.available=function(t){var e=this,n=t.getTransitions();return this.$q.when(this.lastPromise).then(function(){var t=n[e.currentState.name];return Object.keys(t)}).catch(function(){var t=n[e.currentState.name];return e.$q.when(Object.keys(t))})},SyncStrategy.prototype.send=function(u,h,g){var y=this;return this.lastPromise=this.$q.when(this.lastPromise).then(function(){var t=u.getTransitions()[y.currentState.name];if(!y.hasMessage(u,h)||!t.hasOwnProperty(h))return y.lastPromise=null,y.$q.reject();var e=t[h];if(e instanceof Array){var n=[];for(var r in e){var a={};delete(a=angular.merge(a,y.currentState)).action,g&&angular.merge(a.params,g);var i=e[r];y.$injector.invoke(i.predicate,this,a)&&n.push(i.to)}if(1<n.length)throw"Unable to execute transition in state '"+y.currentState.name+"'. More than one predicate is passed.";e=n[0]}var s=u.getStates()[e],o={};delete(o=angular.merge(o,y.currentState)).action,g&&angular.merge(o.params,g);var c=void 0;return!s.action||"function"!=typeof s.action&&"[object Array]"!==Object.prototype.toString.call(s.action)||(c=y.$injector.invoke(s.action,y,o)),y.$q.when(c).then(function(t){!t&&y.currentState.params?s.params=y.currentState.params:(s.hasOwnProperty("params")||(s.params={}),angular.merge(s.params,t)),y.currentState=s}).catch(function(){return y.lastPromise=null,y.$q.reject()})}),this.lastPromise};